/******************************************************************************/
/*                                                                            */
/*   talkstd.c:                                                               */
/*   ~~~~~~~~~~                                                               */
/*                                                                            */
/*   This file contains the functions that support the standard message       */
/*   structure.  The standard message is composed of variable length ASCII    */
/*   fields separated by a delimitor.  The first character defines the        */
/*   delimitor to be used for the message.  The first field is a code         */
/*   representing the return status or command name.  The second field is     */
/*   a human readable string describing the message.  The subsequent fields   */
/*   are data fields.                                                         */
/*                                                                            */
/******************************************************************************/


/******************************************************************************/
/* The following are the standard include statements.                         */

#ifndef _INCLUDE_POSIX_SOURCE
#define _INCLUDE_POSIX_SOURCE
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <varargs.h>
#include <time.h>

/* End of standard includes.                                                  */
/******************************************************************************/


/******************************************************************************/
/* The following are include statements for local files.                      */

#include "trcutil.h"
#include "talkstd.h"

/* End of include statements for local files.                                 */
/******************************************************************************/


/******************************************************************************/
/* The following are global variable definitions.                             */

/* End of global variable definitions.                                        */
/******************************************************************************/


/*******************************************************************************

   TLK_SrvReceive:                                    Date:  November 1994
   ~~~~~~~~~~~~~~~                                  Author:  Sebastien Spicer

   This function is will retrieve a message from a client.  If a message is
   not received within a reasonable time frame, the function returns with
   a timeout.

      Arguments:
      ~~~~~~~~~~
         - dmq (type is *DMQ_parms - Read/Write):
	      The referenced structure represents the MCS server's primary
	      queue. The function will wait on it, attempting to read a message.

         - packet (type is *DMQ_pckt - Read/Write):
	      The referenced structure will contain an inbound message.  The
	      contents of packet are set only if a message is received.

      Returns:
      ~~~~~~~~
         Type is int - coded value representing the completion status of the
         function.

      Modifications:
      ~~~~~~~~~~~~~~
         - Author                     Date
	   Description...

*******************************************************************************/

int TLK_SrvReceive (DMQ_parms *dmq,
		    DMQ_pckt  *packet) {

  char string[_TLK_FLDSZ];
  int status;

  if ((status = DMQ_ServerGet (dmq, packet)) != _DMQ_SUCCESS)
    return (status);

  if (packet->buffLen > 0) {
    TRC_Trace2 (_TLK_MSG_GOTDATA, TRC_GetTime (), packet->buffLen,
		dmq->get.source.au.group, dmq->get.source.au.queue);
    TRC_Trace3 (_TLK_MSG_HEADER, TLK_GetStatusFld (packet),
		TLK_GetDescrFld (packet));
    if (TRC_Verbose >= 4) {
      if (TLK_GetFirstField (packet, string, _TLK_FLDSZ) == _TLK_SUCCESS)
	TRC_Send (_TLK_MSG_DATAFLD, string);
      while (TLK_GetNextField (packet, string, _TLK_FLDSZ) == _TLK_SUCCESS)
	TRC_Send (_TLK_MSG_DATAFLD, string);
    }
  }

  return (status);
}

/*********************** End of function TLK_SrvReceive ***********************/


/*******************************************************************************

   TLK_SrvSubmit:                                     Date:  November 1994
   ~~~~~~~~~~~~~~                                   Author:  Sebastien Spicer

   This function will submit a reply to a client.  The reply considers the
   completion status of the transaction generated by the originating query.

      Arguments:
      ~~~~~~~~~~
         - dmq (type is *DMQ_parms - Read/Write):
	      The referenced structure represents the MCS server's primary
	      queue. The function will wait on it, attempting to read a message.

         - packet (type is *DMQ_pckt - Read only):
	      The referenced structure contains the outbound message.

	 - xCode (type is int - Read only):
              The coded value indicates if the server successfuly completed
	      the transaction.  If an error occured, xCode should be non
	      zero.

      Returns:
      ~~~~~~~~
         Type is int - coded value representing the completion status of the
         function.

      Modifications:
      ~~~~~~~~~~~~~~
         - Author                     Date
	   Description...

*******************************************************************************/

int TLK_SrvSubmit (DMQ_parms *dmq,
		   DMQ_pckt  *packet,
		   int       xCode) {

  char string[_TLK_FLDSZ];
  int status;

  if ((status = DMQ_ServerPut (dmq, packet, xCode)) != _DMQ_SUCCESS)
    return (status);
  
  if (packet->buffLen > 0) {
    TRC_Trace2 (_TLK_MSG_PUTDATA, TRC_GetTime (), packet->buffLen,
		dmq->put.target.au.group, dmq->put.target.au.queue);
    TRC_Trace3 (_TLK_MSG_HEADER, TLK_GetStatusFld (packet),
		TLK_GetDescrFld (packet));
    if (TRC_Verbose >= 4) {
      if (TLK_GetFirstField (packet, string, _TLK_FLDSZ) == _TLK_SUCCESS)
	TRC_Send (_TLK_MSG_DATAFLD, string);
      while (TLK_GetNextField (packet, string, _TLK_FLDSZ) == _TLK_SUCCESS)
	TRC_Send (_TLK_MSG_DATAFLD, string);
    }
  }

  return (status);
}

/************************ End of function TLK_SrvSubmit ***********************/


/*******************************************************************************

   TLK_CltReceive:                                    Date:  November 1994
   ~~~~~~~~~~~~~~~                                  Author:  Sebastien Spicer

   This function is will retrieve a message from the server.  If a message is
   not received within a reasonable time frame, the function returns with
   a timeout.

      Arguments:
      ~~~~~~~~~~
         - dmq (type is *DMQ_parms - Read/Write):
	      The referenced structure represents the MCS server's primary
	      queue. The function will wait on it, attempting to read a message.

         - packet (type is *DMQ_pckt - Read/Write):
	      The referenced structure will contain an inbound message.  The
	      contents of packet are set only if a message is received.

      Returns:
      ~~~~~~~~
         Type is int - coded value representing the completion status of the
         function.

      Modifications:
      ~~~~~~~~~~~~~~
         - Author                     Date
	   Description...

*******************************************************************************/

int TLK_CltReceive (DMQ_parms *dmq,
		    DMQ_pckt  *packet) {

  char string[_TLK_FLDSZ];
  int status;

  if ((status = DMQ_ClientGet (dmq, packet)) != _DMQ_SUCCESS)
    return (status);

  if (packet->buffLen > 0) {
    TRC_Trace2 (_TLK_MSG_GOTDATA, TRC_GetTime (), packet->buffLen,
		dmq->get.source.au.group, dmq->get.source.au.queue);
    TRC_Trace3 (_TLK_MSG_HEADER, TLK_GetStatusFld (packet),
		TLK_GetDescrFld (packet));
    if (TRC_Verbose >= 4) {
      if (TLK_GetFirstField (packet, string, _TLK_FLDSZ) == _TLK_SUCCESS)
	TRC_Send (_TLK_MSG_DATAFLD, string);
      while (TLK_GetNextField (packet, string, _TLK_FLDSZ) == _TLK_SUCCESS)
	TRC_Send (_TLK_MSG_DATAFLD, string);
    }
  }

  return (status);
}

/*********************** End of function TLK_CltReceive ***********************/


/*******************************************************************************

   TLK_CltSubmit:                                     Date:  November 1994
   ~~~~~~~~~~~~~~                                   Author:  Sebastien Spicer

   This function will submit a query to a server.  The reply considers the
   completion status of the transaction generated by the originating query.

      Arguments:
      ~~~~~~~~~~
         - dmq (type is *DMQ_parms - Read/Write):
	      The referenced structure represents the MCS server's primary
	      queue. The function will wait on it, attempting to read a message.

         - packet (type is *DMQ_pckt - Read only):
	      The referenced structure contains the outbound message.

      Returns:
      ~~~~~~~~
         Type is int - coded value representing the completion status of the
         function.

      Modifications:
      ~~~~~~~~~~~~~~
         - Author                     Date
	   Description...

*******************************************************************************/

int TLK_CltSubmit (DMQ_parms *dmq,
		   DMQ_pckt  *packet) {

  char string[_TLK_FLDSZ];
  int status;

  if ((status = DMQ_ClientPut (dmq, packet)) != _DMQ_SUCCESS)
    return (status);
  
  if (packet->buffLen > 0) {
    TRC_Trace2 (_TLK_MSG_PUTDATA, TRC_GetTime (), packet->buffLen,
		dmq->put.target.au.group, dmq->put.target.au.queue);
    TRC_Trace3 (_TLK_MSG_HEADER, TLK_GetStatusFld (packet),
		TLK_GetDescrFld (packet));
    if (TRC_Verbose >= 4) {
      if (TLK_GetFirstField (packet, string, _TLK_FLDSZ) == _TLK_SUCCESS)
	TRC_Send (_TLK_MSG_DATAFLD, string);
      while (TLK_GetNextField (packet, string, _TLK_FLDSZ) == _TLK_SUCCESS)
	TRC_Send (_TLK_MSG_DATAFLD, string);
    }
  }

  return (status);
}

/************************ End of function TLK_CltSubmit ***********************/


/*******************************************************************************

   TLK_GetStatusFld:                                  Date:  November 1994
   ~~~~~~~~~~~~~~~~~                                Author:  Sebastien Spicer

   This function will return the status field from the message header.

      Arguments:
      ~~~~~~~~~~
         - packet (type is *DMQ_pckt - Read only):
	      The referenced structure contains the message.

      Returns:
      ~~~~~~~~
         Type is *char - pointer to string that will contain the status code.
	 Do not free the string.

      Modifications:
      ~~~~~~~~~~~~~~
         - Author                     Date
	   Description...

*******************************************************************************/

char *TLK_GetStatusFld (DMQ_pckt *packet) {

  int status;
  short int hold;
  static char string[_TLK_FLDSZ];
  
  hold = packet->buffPtr;
  packet->buffPtr = 1;
  status = TLK_GetNextField (packet, string, _TLK_FLDSZ);
  packet->buffPtr = hold;

  if (status == _TLK_SUCCESS)
    return (string);
  else
    return (NULL);
}

/********************* End of function TLK_GetStatusFld ***********************/


/*******************************************************************************

   TLK_GetDescrFld:                                   Date:  November 1994
   ~~~~~~~~~~~~~~~~                                 Author:  Sebastien Spicer

   This function will return the description field from the message header.

      Arguments:
      ~~~~~~~~~~
         - packet (type is *DMQ_pckt - Read only):
	      The referenced structure contains the message.

      Returns:
      ~~~~~~~~
         Type is *char - pointer to string that will contain the description.
	 Do not free the string.

      Modifications:
      ~~~~~~~~~~~~~~
         - Author                     Date
	   Description...

*******************************************************************************/

char *TLK_GetDescrFld (DMQ_pckt *packet) {

  int status;
  short int hold;
  static char string[_TLK_FLDSZ];
  
  hold = packet->buffPtr;
  packet->buffPtr = 1;
  if ((status = TLK_GetNextField (packet, string, _TLK_FLDSZ)) == _TLK_SUCCESS)
    status = TLK_GetNextField (packet, string, _TLK_FLDSZ);
  packet->buffPtr = hold;

  if (status == _TLK_SUCCESS)
    return (string);
  else
    return (NULL);
}

/********************** End of function TLK_GetDescrFld ***********************/


/*******************************************************************************

   TLK_GetFirstField:                                 Date:  November 1994
   ~~~~~~~~~~~~~~~~~~                               Author:  Sebastien Spicer

   This function will retrieve the field field in the message buffer.

      Arguments:
      ~~~~~~~~~~
         - packet (type is *DMQ_pckt - Read/Write):
	      The referenced structure contains the message.  The message
	      pointer will be modified.

	 - data (type is *void - Read/Write):
              The referenced data element is of the specified type.  Its
	      contents will be loaded with data from the next TP field.

	 - type (type is int - Read only):
	      The coded integer represents the type of data.  If the value
	      of type is greater than 0, the type is a string and the value
	      of type represents the size of the string.

      Returns:
      ~~~~~~~~
         Type is int - coded value representing the completion status of the
         function.

      Modifications:
      ~~~~~~~~~~~~~~
         - Author                     Date
	   Description...

*******************************************************************************/

int TLK_GetFirstField (DMQ_pckt *packet,
		       void     *data,
		       int      type) {

  int status;
  char string[_TLK_FLDSZ];

  packet->buffPtr = 1;
  if ((status = TLK_GetNextField (packet, string, _TLK_FLDSZ)) != _TLK_SUCCESS)
    return (status);
  if ((status = TLK_GetNextField (packet, string, _TLK_FLDSZ)) != _TLK_SUCCESS)
    return (status);
  return (TLK_GetNextField (packet, data, type));
}

/********************* End of function TLK_GetFirstField **********************/


/*******************************************************************************

   TLK_GetNextField:                                  Date:  November 1994
   ~~~~~~~~~~~~~~~~~                                Author:  Sebastien Spicer

   This function will retrieve the next field in the message buffer.
   A call to TLK_GetFirstField is required to initialize the pointer.

      Arguments:
      ~~~~~~~~~~
         - packet (type is *DMQ_pckt - Read/Write):
	      The referenced structure contains the message.  The message
	      pointer will be modified.

	 - data (type is *void - Read/Write):
              The referenced data element is of the specified type.  Its
	      contents will be loaded with data from the next TP field.

	 - type (type is int - Read only):
	      The coded integer represents the type of data.  If the value
	      of type is greater than 0, the type is a string and the value
	      of type represents the size of the string.

      Returns:
      ~~~~~~~~
         Type is int - coded value representing the completion status of the
         function.

      Modifications:
      ~~~~~~~~~~~~~~
         - Author                     Date
	   Description...

*******************************************************************************/

int TLK_GetNextField (DMQ_pckt *packet,
		      void     *data,
		      int      type) {

  char *endPtr, string[_TLK_FLDSZ], temp[_TLK_FLDSZ];
  int  fldLen, status = _TLK_SUCCESS;
  struct tm fmtTime1, fmtTime2;

  if ((fldLen = packet->buffLen - packet->buffPtr) <= 0)
    status = _TLK_FAILURE;

  else if ((endPtr = (char *) memchr (&packet->buffer[packet->buffPtr],
				      (int) packet->buffer[0], fldLen)) == NULL)
    status = _TLK_FAILURE;

  else if ((fldLen = endPtr - &packet->buffer[packet->buffPtr]) >= _TLK_FLDSZ)
    fldLen = _TLK_FLDSZ - 1;

  if (status == _TLK_SUCCESS) {
    memcpy (string, &packet->buffer[packet->buffPtr], fldLen);
    string[fldLen] = 0;
    packet->buffPtr += fldLen + 1;

    if (type > 0)
      strncpy ((char *) data, string, type);
    else
      switch (type) {
      case _TLK_CHAR:
	*((char *) data) = string[0];
	break;
      case _TLK_INT:
	*((int *) data) = (int) atol (string);
	break;
      case _TLK_DOUBLE:
	*((double *) data) = (double) atol (string);
	break;
#ifdef VMS
#else
      case _TLK_PID:
	*((pid_t *) data) = (pid_t) atol (string);
	break;
#endif
      case _TLK_VAXTIME:
	temp[2] = 0;
	strncpy (temp, &string[0], 2);
	fmtTime1.tm_mday = atoi (temp);
	temp[3] = 0;
	strncpy (temp, &string[3], 3);
	if (strcmp (temp, "JAN") == 0) fmtTime1.tm_mon = 0;  else
	if (strcmp (temp, "FEB") == 0) fmtTime1.tm_mon = 1;  else
	if (strcmp (temp, "MAR") == 0) fmtTime1.tm_mon = 2;  else
	if (strcmp (temp, "APR") == 0) fmtTime1.tm_mon = 3;  else
	if (strcmp (temp, "MAY") == 0) fmtTime1.tm_mon = 4;  else
	if (strcmp (temp, "JUN") == 0) fmtTime1.tm_mon = 5;  else
	if (strcmp (temp, "JUL") == 0) fmtTime1.tm_mon = 6;  else
	if (strcmp (temp, "AUG") == 0) fmtTime1.tm_mon = 7;  else
	if (strcmp (temp, "SEP") == 0) fmtTime1.tm_mon = 8;  else
	if (strcmp (temp, "OCT") == 0) fmtTime1.tm_mon = 9;  else
	if (strcmp (temp, "NOV") == 0) fmtTime1.tm_mon = 10; else
	if (strcmp (temp, "DEC") == 0) fmtTime1.tm_mon = 11; else {
	  status = _TLK_FAILURE;
	  break;
	}
	temp[4] = 0;
	strncpy (temp, &string[7], 4);
	fmtTime1.tm_year = atoi (temp) - 1900;
	temp[2] = 0;
	strncpy (temp, &string[12], 2);
	fmtTime1.tm_hour = atoi (temp);
	strncpy (temp, &string[15], 2);
	fmtTime1.tm_min = atoi (temp);
	strncpy (temp, &string[18], 2);
	fmtTime1.tm_sec = atoi (temp);
	fmtTime2 = fmtTime1;
	fmtTime1.tm_isdst = 1;
	fmtTime2.tm_isdst = 0;
	*((time_t *) data) = mktime (&fmtTime1);
	endPtr = ctime ((time_t *) data);
	if (strncmp (&string[12], &endPtr[11], 2) != 0)
	  *((time_t *) data) = mktime (&fmtTime2);
	break; 
      default:
	status = _TLK_FAILURE;
	break;
      }
  }

  return (status);
}

/********************* End of function TLK_GetNextField ***********************/


/*******************************************************************************

   TLK_PutMsgHeader:                                  Date:  November 1994
   ~~~~~~~~~~~~~~~~~                                Author:  Sebastien Spicer

   This function will put the message header into the message buffer.  This
   essentially initializes the buffer for a new message.

      Arguments:
      ~~~~~~~~~~
         - packet (type is *DMQ_pckt - Read/Write):
	      The referenced structure contains the message.  The message
	      buffer will be initialized and will contain the new header.

	 - statStr (type is *char - Read only):
	      The referenced string contains the status/command code to
	      be inserted into the header.

	 - statMsg (type is *char - Read only):
	      The referenced string contains the status/command description
	      to be inserted into the header.

	 - delimit (type is char - Read only):
	      The character defines the delimitor to be used for this 
	      message.

      Returns:
      ~~~~~~~~
         Type is int - coded value representing the completion status of the
         function.

      Modifications:
      ~~~~~~~~~~~~~~
         - Author                     Date
	   Description...

*******************************************************************************/

int TLK_PutMsgHeader (DMQ_pckt *packet,
		      char     *statStr,
		      char     *statMsg,
		      char     delimit) {

  int status;

  packet->buffLen = 1;
  packet->buffer[0] = delimit;
  packet->class = _TLK_CLASS;
  if ((status = TLK_PutNextField (packet, "%s", statStr)) != _TLK_SUCCESS)
    return (status);
  return (TLK_PutNextField (packet, "%s", statMsg));
}

/********************** End of function TLK_PutMsgHeader **********************/


/*******************************************************************************

   TLK_PutNextField:                                  Date:  November 1994
   ~~~~~~~~~~~~~~~~~                                Author:  Sebastien Spicer

   This function will put the next field in the message buffer.

      Arguments:
      ~~~~~~~~~~
         - packet (type is *DMQ_pckt - Read/Write):
	      The referenced structure contains the message.  The new field
	      will be added to the buffer.

         - format (type is *char - Read only):
	      A pointer to a string which contains the format specifier for
	      the field to be added.

	 Subsequent arguments are variable and follow the same style as those
	 for printf.

      Returns:
      ~~~~~~~~
         Type is int - coded value representing the completion status of the
         function.

      Modifications:
      ~~~~~~~~~~~~~~
         - Author                     Date
	   Description...

*******************************************************************************/

int TLK_PutNextField (packet, format, va_alist)
     DMQ_pckt *packet;
     char     *format;
     va_dcl

{
  va_list argptr;
  int     fieldLen;

  va_start (argptr);
  fieldLen = vsprintf (&packet->buffer[packet->buffLen], format, argptr);
  va_end (argptr);
  packet->buffLen += fieldLen;
  packet->buffer[packet->buffLen++] = packet->buffer[0];
  packet->buffer[packet->buffLen] = 0;
  return (_TLK_SUCCESS);
}

/********************** End of function TLK_PutNextField **********************/


char
all_space(char *test_string)
{
  char space_c;

 
  short tmpvar;

  space_c = TRUE;

  for ( tmpvar=0; tmpvar<strlen(test_string); tmpvar++)
    if ( test_string[tmpvar] != ' ' && test_string[tmpvar] != 0 ) 
        space_c = FALSE;

  return(space_c);
}
/******************************************************************************/
/*************************** End of file talkstd.c ****************************/
/******************************************************************************/












